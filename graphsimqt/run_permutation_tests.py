import graph_tool as gt
import graph_tool.generation as gtg
import pandas as pd
from pathlib import Path
import argparse
from typing import Union
from progress.spinner import Spinner
from progress.bar import IncrementalBar
from graphsimqt.utils.graph_distance import GraphDistance
from graphsimqt.utils.get_result_directory_path import get_result_directory_path


def _add_to_results(distances: GraphDistance, permuted: bool, distance_type: str, global_distances: dict,
                    local_distances: dict):
    global_distances['permuted'].append(permuted)
    global_distances['distance_type'].append(distance_type)
    global_distances['distance'].append(distances.global_distance)
    for node_id, distance in distances.local_distances.items():
        local_distances['permuted'].append(permuted)
        local_distances['distance_type'].append(distance_type)
        local_distances['node'].append(node_id)
        local_distances['distance'].append(distance)


def _filter_exclusive_nodes(graph_1: gt.Graph, graph_2: gt.Graph):
    node_ids_1 = {graph_1.vertex_properties['ID'][node] for node in graph_1.vertices()}
    node_ids_2 = {graph_2.vertex_properties['ID'][node] for node in graph_2.vertices()}
    common_diseases = node_ids_1.intersection(node_ids_2)
    is_common_node_1 = graph_1.new_vp('bool')
    for node in graph_1.vertices():
        is_common_node_1[node] = graph_1.vertex_properties['ID'][node] in common_diseases
    is_common_node_2 = graph_2.new_vp('bool')
    for node in graph_2.vertices():
        is_common_node_2[node] = graph_2.vertex_properties['ID'][node] in common_diseases
    graph_1.set_vertex_filter(is_common_node_1)
    graph_1.purge_vertices()
    graph_1.clear_filters()
    graph_2.set_vertex_filter(is_common_node_2)
    graph_2.purge_vertices()
    graph_2.clear_filters()


def _ensure_same_directedness(graph_1: gt.Graph, graph_2: gt.Graph):
    if graph_1.is_directed() != graph_2.is_directed():
        graph_1.set_directed(False)
        graph_2.set_directed(False)
        edge_property_names = list(graph_1.edge_properties.keys())
        for edge_property_name in edge_property_names:
            del graph_1.edge_properties[edge_property_name]
        edge_property_names = list(graph_2.edge_properties.keys())
        for edge_property_name in edge_property_names:
            del graph_2.edge_properties[edge_property_name]


def run_permutation_tests(path_to_graph_1: Union[str, Path], path_to_graph_2: Union[str, Path], result_directory_name: str,
                          num_permutations: int = 1000, silent: bool = False):
    """Runs permutation tests and saves global and local distances for original and permuted graphs as CSV files.

    Parameters
    ----------
    path_to_graph_1 : str or pathlib.Path
        Path to first normalized input graph generated by normalize_graph.py.
    path_to_graph_2 : str or pathlib.Path
        Path to second normalized input graph generated by normalize_graph.py.
    result_directory_name : str
        Name of the subdirectory of the results/ directory where the results should be saved.
        Will be created if it does not exist already.
    num_permutations : int, default: 1000
        Number of permutations.
    silent : bool, default: False
        Set to True to suppress printing progress to stdout.

    """
    if not silent:
        spinner = Spinner('Preparing permutation tests. ')
        spinner.next()
    graph_1 = gt.load_graph(str(path_to_graph_1))
    if not silent:
        spinner.next()
    graph_2 = gt.load_graph(str(path_to_graph_2))
    if not silent:
        spinner.next()
    _filter_exclusive_nodes(graph_1, graph_2)
    node_ids = [graph_1.vertex_properties['ID'][node] for node in graph_1.vertices()]
    global_distances = {'permuted': [], 'distance_type': [], 'distance': []}
    local_distances = {'permuted': [], 'distance_type': [], 'node': [], 'distance': []}
    if 'NORM-SCORE' in graph_1.edge_properties and 'NORM-SCORE' in graph_2.edge_properties:
        edge_properties = {'topology_only': None,
                           'normalized_scores': (graph_1.edge_properties['NORM-SCORE'],
                                                 graph_2.edge_properties['NORM-SCORE']),
                           'normalized_ranks': (graph_1.edge_properties['NORM-RANK'],
                                                graph_2.edge_properties['NORM-RANK'])}
    else:
        edge_properties = {'topology_only': None}
    for distance_type, edge_property in edge_properties.items():
        if not silent:
            spinner.next()
        distances = GraphDistance(graph_1, graph_2, node_ids, edge_property)
        _add_to_results(distances, False, distance_type, global_distances, local_distances)
    if not silent:
        spinner.finish()
        bar = IncrementalBar('Running permutation tests.', max=num_permutations)
    for _ in range(num_permutations):
        if not silent:
            bar.next()
        gtg.random_rewire(graph_1, n_iter=100)
        gtg.random_rewire(graph_2, n_iter=100)
        for distance_type, edge_property in edge_properties.items():
            distances = GraphDistance(graph_1, graph_2, node_ids, edge_property)
            _add_to_results(distances, True, distance_type, global_distances, local_distances)
    if not silent:
        bar.finish()
        spinner = Spinner('Saving results of permutation tests. ')
        spinner.next()

    local_distances = pd.DataFrame(data=local_distances)
    global_distances = pd.DataFrame(data=global_distances)
    result_dir_path = get_result_directory_path(result_directory_name)
    result_dir_path.mkdir(exist_ok=True)
    path_to_local_distances = result_dir_path.joinpath('local_distances.csv')
    path_to_global_distances = result_dir_path.joinpath('global_distances.csv')
    local_distances.to_csv(str(path_to_local_distances), index=False)
    global_distances.to_csv(str(path_to_global_distances), index=False)
    if not silent:
        spinner.finish()
        print(f'Saved global distances to {str(path_to_global_distances)}.')
        print(f'Saved local distances to {str(path_to_local_distances)}.')


if __name__ == '__main__':
    parser = argparse.ArgumentParser('Run permutation tests.')
    parser.add_argument('path_to_graph_1', type=Path, help='Path to first normalized input graph generated by '
                                                           'normalize_graph.py.')
    parser.add_argument('path_to_graph_2', type=Path, help='Path to second normalized input graph generated by '
                                                           'normalize_graph.py.')
    parser.add_argument('--dirname', type=str, help='Name of the subdirectory of the results/ directory where the '
                                                    'results should be saved. Will be created if it does not exist '
                                                    'already.', required=True)
    parser.add_argument('--permutations', type=int, help='Number of permutations. Default: 1000.', default=1000)
    parser.add_argument('--silent', action='store_true', help='Set this flag to suppress printing progress to stdout.')
    args = parser.parse_args()
    run_permutation_tests(args.path_to_graph_1, args.path_to_graph_2, args.dirname, args.permutations, args.silent)
